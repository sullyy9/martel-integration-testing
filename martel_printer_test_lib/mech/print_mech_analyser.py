from pathlib import Path
from typing import Final, Optional, Protocol

import time
from tempfile import TemporaryDirectory
from typing import Self
import weakref
from weakref import finalize

from robot.libraries.BuiltIn import BuiltIn

from . import printout_generation
from printout import Printout
from .signal_analyser import SaleaeLogic8
from .printout_generation import PrintMechState, PaperBuffer

class MechPrintError(Exception):
    pass


class MechFileError(Exception):
    pass

class PrintMechAnalyzer(Protocol):
    def set_capture_output_directory(self, directory: Optional[Path]):
        ...

    def set_printout_output_directory(self, directory: Optional[Path]):
        ...

    def start_capture(self, name: Optional[str] = None) -> None:
        """
        Start capturing the output from the print mechanism.
        """
        ...

    def stop_capture(self) -> None:
        ...

    def wait_until_print_complete(self) -> None:
        ...

    def get_last_printout(self) -> Printout:
        ...

class LTPD245Emulator(PrintMechAnalyzer):
    """
    Emulator for the Seiko LTPD245 print mechanism.

    """
    __slots__ = ('_analyser', '_capture', '_output_path', '_capture_path',
                 '_printout_path', '_capture_name', 'cleanup')

    def __init__(self,
                 capture_directory: Optional[Path] = None,
                 printout_directory: Optional[Path] = None
                 ) -> None:
        """
        Parameters
        ----------
        capture_directory: Path | None
            Directory where CSV files generated by the logic analyzer will be
            placed.

        printout_directory: Path | None
            Directory where digital printout PNG images will be placed.

        """
        self._analyser: Final[SaleaeLogic8] = SaleaeLogic8()
        self._capture_path: Path | TemporaryDirectory = TemporaryDirectory()
        self._printout_path: Optional[Path] = None

        self._capture: Optional[Path] = None
        self._capture_name: Optional[str] = None
        self._printout: Optional[Printout] = None

        self.cleanup: Final[finalize] = weakref.finalize(self, self._cleanup)

        self.set_capture_output_directory(capture_directory)
        self.set_printout_output_directory(printout_directory)

    def __enter__(self) -> Self:
        return self

    def __del__(self) -> None:
        self.cleanup()

    def __exit__(self, exc_type, exc_value, exc_traceback) -> None:
        self.cleanup()

    def _cleanup(self) -> None:
        self._analyser.cleanup()

    def set_capture_output_directory(self, directory: Optional[Path]):
        """
        Select the directory where CSV files generated by the logic analyzer
        will be placed. If None is specified, the files will not be saved.

        Parameters
        ----------
        directory : Optional[Path]
            Path to an existing directory or none.

        Raises
        ------
        MechFileError
            If the directory doesn't exist.

        """
        if directory and directory.exists():
            self._capture_path = directory
        elif directory:
            raise MechFileError(
                'Cannot output printouts to {directory}.'
                'Directory does not exist'
            )
        else:
            self._capture_path = TemporaryDirectory()

    def set_printout_output_directory(self, directory: Optional[Path]):
        """
        Select the directory where digital printout PNG images will be placed.
        If None is specified, the files will not be saved.

        Parameters
        ----------
        directory : Optional[Path]
            Path to an existing directory or none.

        Raises
        ------
        MechFileError
            If the directory doesn't exist.

        """
        if directory and directory.exists():
            self._printout_path = directory
        elif directory:
            raise MechFileError(
                'Cannot output printouts to {directory}.'
                'Directory does not exist'
            )
        else:
            self._printout_path = None

    def start_capture(self, name: Optional[str] = None) -> None:
        """
        Start capturing the output from the print mechanism.

        Parameters
        ----------
        name : str | None
            Name used when saving any files.

        """
        self._capture_name = name
        self._analyser.start_print_capture()
        time.sleep(0.1) # Give the analyzer a little bit of time to start up.

    def stop_capture(self) -> None:
        pass

    def wait_until_print_complete(self) -> None:
        """
        Wait until a print has finished. Export the captured data to the output
        directory if one has been specified, otherwise store it in a temporary
        directory.
        """
        self._analyser.wait_until_capture_complete()

        timestamp = time.strftime('%Y%m%d-%H%M%S')
        filename = self._capture_name if self._capture_name else timestamp

        if isinstance(self._capture_path, TemporaryDirectory):
            path = Path(self._capture_path.name)
        elif isinstance(self._capture_path, Path):
            path = self._capture_path
        else:
            raise MechPrintError('No capture path set')

        capture_path = Path(path, filename).with_suffix('.csv')
        self._analyser.export_capture(capture_path)
        self._capture = capture_path

        # Save the printout if a path has been set.
        self._printout = self._generate_image_from_capture(self._capture)
        if self._printout_path:
            printout_path = Path(self._printout_path,
                                 filename).with_suffix('.png')
            self._printout.save(printout_path)

        self._analyser.clear_capture()

    def get_last_printout(self) -> Printout:
        if self._printout:
            return self._printout
        else:
            raise MechPrintError('Cannot get last printout as none exists')

    def _generate_image_from_capture(self, capture: Path) -> Printout:
        states = printout_generation.read_mech_input(capture)
        print_mech = PrintMechState(next(states))
        
        for state in states:
            print_mech.update(state)
        
        return print_mech.get_printout()


class EyeballMk1(PrintMechAnalyzer):
    def set_capture_output_directory(self, directory: Optional[Path]):
        pass

    def set_printout_output_directory(self, directory: Optional[Path]):
        pass

    def set_output_directories(self, directory: Path) -> None:
        pass

    def start_capture(self) -> None:
        pass

    def stop_capture(self) -> None:
        pass

    def wait_until_print_complete(self) -> None:
        pass

    def get_last_printout(self) -> Printout:
        return PaperBuffer().as_printout()

    def save_last_printout(self) -> None:
        pass
